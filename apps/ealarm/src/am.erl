%% @author ezheluo
%% @doc Alarm manager module, this is a more comphrehensive alarm handler as
%%      supposed to the one deliverd as part of SASL. SASL Alarm Handler 
%%      a gen_event process.  When it is started, a simple event handler 
%%      which logs all alarms is installed. It can only manage active alarms.
%%      The objective of this module is to keep records of historical alarms,
%%      as well as manage active alarms. 
%%%-----------------------------------------------------------------
%% @end


-module(am).
-behaviour(gen_event).
-export([init/1, handle_event/2, handle_call/2, handle_info/2, terminate/2, code_change/3]).
-export([start_link/0,
         quick_raise/5, raise/1, clear/1, get_alarms/0,
         get_active/0, get_historical/0,
         pr_active/0, pr_historical/0]).

%%
%% alarm records
%%
%% ====================================================================
%% Alarm definition 
%% purposefully incompleted implementation of 3gpp 328.29-a00,
%% 3gpp alarm Intergration Reference Point
%% ====================================================================

-type alarm_severity() :: critical | major | minor | warning | info.
-record (alarm, 
                {
                 %% unqiue alarm id, for now it must be generated by the application
                 alarmId :: atom(),

                 %% the time is generated by this module
                 %% erlang system time that might not be align with OS or eNodeB/GPS/NTP time at all.
                 alarmRaisedTime,

                 %% the alarm last seen 
                 alarmChangedTime,

                 %% the alarm cleared time for historical alarm record keeping
                 alarmClearedTime = active,

                 %% more human readable form and non-3GPP standard
                 alarmRaisedUTCTime,
                 alarmChangedUTCTime,
                 alarmClearedUTCTime,
                 
                 %% alarm duplication counter(Non-3GPP)
                 counter = 1 :: integer(),

                 %% describe probably cause
                 probableCause            :: string(),
                 perceivedSeverity = info :: alarm_severity(),
                 specificProblem          :: string(),
                 proposedRepairActions    :: string(),

                 %% modules or components 
                 source :: atom()
        }).
%%
%% separate two lists of active and historical alarms
%%
-record(alarms_state,
        %% a list of alarms in key and value pair.
        %% The key is a unique alarm id.
        %% The value is an alarm record.
        {active_alarms     ,  %% [{atom(), #alarm{}}],    
         historical_alarms}). %% [{atom(), #alarm{}}]}).

%% ====================================================================
%% API functions
%% ====================================================================
start_link() ->
    case gen_event:start_link({local, ?MODULE}) of
    {ok, Pid} ->
        gen_event:add_handler(?MODULE, ?MODULE, []),
        {ok, Pid, ?MODULE};
    Error -> Error
    end.

%%-----------------------------------------------------------------
%% Func: set_alarm/1
%% Args: Alarm ::= {AlarmId, term()}
%%       where AlarmId ::= term()
%%-----------------------------------------------------------------
raise(Alarm) ->
    gen_event:sync_notify(?MODULE, {raise_alarm, Alarm}).

%%
%%
%% @doc Quick raise an alarm without creating a lengthy record.
%%
-spec quick_raise(atom(), alarm_severity(), atom(), string(), string()) ->
                        ok | {duplicated, #alarm{}}.
quick_raise(AlarmId, Severity, Module, Description, Actions) when is_atom(AlarmId)->
    Alarm = #alarm{alarmId = AlarmId,
                  perceivedSeverity = Severity,
                  specificProblem = Description,
                  proposedRepairActions = Actions,
                  source = Module},
    raise(Alarm);
quick_raise(_, _, _, _, _) ->  atom_alarm_id_only.

%%-----------------------------------------------------------------
%% Func: clear_alarm/1
%% Args: AlarmId ::= term()
%%-----------------------------------------------------------------
clear(AlarmId) when is_atom(AlarmId) ->
    gen_event:sync_notify(?MODULE, {clear_alarm, AlarmId});
clear(_) -> atom_alarm_id_only.

%%-----------------------------------------------------------------
%% Func: get_alarms/0
%% Returns: [{AlarmId, AlarmDesc}]
%%-----------------------------------------------------------------
get_alarms() ->
    gen_event:call(?MODULE, ?MODULE, get_alarms).
get_active() ->
    gen_event:call(?MODULE, ?MODULE, get_active_alarms).
get_historical() ->
    gen_event:call(?MODULE, ?MODULE, get_historical_alarms).

-spec pr_active() -> list().
pr_active() ->
    [record_to_proplist(X) || {_Id, X} <- get_active()].
-spec pr_historical() -> list().
pr_historical() ->
    [record_to_proplist(X) || {_Id, X} <- get_historical()].

%% add_alarm_handler(Module) when is_atom(Module) ->
%%     gen_event:add_handler(?MODULE, Module, []).
%% 
%% add_alarm_handler(Module, Args) when is_atom(Module) ->
%%     gen_event:add_handler(?MODULE, Module, Args).
%% 
%% delete_alarm_handler(Module) when is_atom(Module) ->
%%     gen_event:delete_handler(?MODULE, Module, []).

%% ====================================================================
%% Behavioural functions
%% ====================================================================


%% init/1
%% ====================================================================
%% @doc <a href="http://www.erlang.org/doc/man/gen_event.html#Module:init-1">gen_event:init/1</a>
-spec init(InitArgs) -> Result when
	InitArgs :: Args | {Args, Term :: term()},
	Args :: term(),
	Result :: {ok, State}
			| {ok, State, hibernate}
			| {error, Reason :: term()},
	State :: term().
%% ====================================================================
init(_) ->
    {ok, #alarms_state{active_alarms=[], historical_alarms=[]}}.


%% handle_event/2
%% ====================================================================
%% @doc <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_event-2">gen_event:handle_event/2</a>
-spec handle_event(Event :: term(), State :: term()) -> Result when
	Result :: {ok, NewState}
			| {ok, NewState, hibernate}
			| {swap_handlers, Args1, NewState, Handler2, Args2}
			| remove_handler,
	NewState :: term(), Args1 :: term(), Args2 :: term(),
	Handler2 :: Module2 | {Module2, Id :: term()},
	Module2 :: atom().
%% ====================================================================  
handle_event({raise_alarm, Alarm}, Alarms)->
    error_logger:info_report([{alarm_raised, {raised, Alarm}}]),
    {ok, add_active_alarm(Alarm, Alarms)};
handle_event({clear_alarm, AlarmId}, Alarms)->
    error_logger:info_report([{alarm_cleared, {clear, AlarmId}}]),

    case clear_active_alarm(AlarmId, Alarms) of
        no_alarm_registerd ->
            {ok, Alarms};
        {cleared, _UpdatedAlarm, NewAlarms} ->
            {ok, NewAlarms}
    end;
handle_event(_, Alarms)->
    {ok, Alarms}.

%% handle_info/2
%% ====================================================================
%% @doc <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_info-2">gen_event:handle_info/2</a>
-spec handle_info(Info :: term(), State :: term()) -> Result when
    Result :: {ok, NewState}
            | {ok, NewState, hibernate}
            | {swap_handler, Args1, NewState, Handler2, Args2}
            | remove_handler,
    NewState :: term(), Args1 :: term(), Args2 :: term(),
    Handler2 :: Module2 | {Module2, Id :: term()},
    Module2 :: atom().
%% ====================================================================
handle_info(_, Alarms) -> {ok, Alarms}.

%% handle_call/2
%% ====================================================================
%% @doc <a href="http://www.erlang.org/doc/man/gen_event.html#Module:handle_call-2">gen_event:handle_call/2</a>
-spec handle_call(Request :: term(), State :: term()) -> Result when
	Result :: {ok, Reply, NewState}
			| {ok, Reply, NewState, hibernate}
			| {swap_handler, Reply, Args1, NewState, Handler2, Args2}
			| {remove_handler, Reply},
	Reply :: term(),
	NewState :: term(), Args1 :: term(), Args2 :: term(),
	Handler2 :: Module2 | {Module2, Id :: term()},
	Module2 :: atom().
%% ====================================================================
handle_call(get_alarms, Alarms) -> {ok, Alarms, Alarms};
handle_call(get_active_alarms, Alarms) ->
    {ok, Alarms#alarms_state.active_alarms, Alarms};
handle_call(get_historical_alarms, Alarms) ->
    {ok, Alarms#alarms_state.historical_alarms, Alarms};
handle_call(Query, Alarms)     -> {ok, {error, bad_query, Query}, Alarms}.

%% terminate/2
%% ====================================================================
%% @doc <a href="http://www.erlang.org/doc/man/gen_event.html#Module:terminate-2">gen_event:terminate/2</a>
-spec terminate(Arg, State :: term()) -> term() when
	Arg :: Args
		| {stop, Reason}
		| stop
		| remove_handler
		| {error, {'EXIT', Reason}}
		| {error, Term :: term()},
	Args :: term(), Reason :: term().
%% ====================================================================
terminate(swap, Alarms) ->
    {?MODULE, Alarms};
terminate(_, _) ->
    ok.

%% code_change/3
%% ====================================================================
%% @doc <a href="http://www.erlang.org/doc/man/gen_event.html#Module:code_change-3">gen_event:code_change/3</a>
-spec code_change(OldVsn, State :: term(), Extra :: term()) -> {ok, NewState :: term()} when
	OldVsn :: Vsn | {down, Vsn},
	Vsn :: term().
%% ====================================================================
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.


%% ====================================================================
%% Internal functions
%% ====================================================================

record_to_proplist(#alarm{} = Rec) ->
  lists:zip(record_info(fields, alarm), tl(tuple_to_list(Rec))).

add_active_alarm(Alarm,  State) when is_record (Alarm, alarm) ->
    ActiveAlarms = State#alarms_state.active_alarms,
    AlarmId = Alarm#alarm.alarmId,

    CurrentTimeStamp = erlang:system_time(),
    DateAndTime = calendar:local_time_to_universal_time_dst(calendar:local_time()),
    case proplists:lookup(AlarmId, ActiveAlarms) of
        none ->
            NewAlarm = 
                Alarm#alarm{alarmRaisedTime=CurrentTimeStamp,
                                   alarmChangedTime=CurrentTimeStamp,
                                   alarmRaisedUTCTime=DateAndTime,
                                   alarmChangedUTCTime=DateAndTime},
            NewActiveAlarms = [{AlarmId, NewAlarm} | ActiveAlarms],
            State#alarms_state{active_alarms = NewActiveAlarms};
        {AlarmId, FoundAlarm} ->
            NewCounter = 1 + FoundAlarm#alarm.counter,
            UpdatedAlarm = FoundAlarm#alarm{alarmChangedTime=CurrentTimeStamp,
                                                   alarmChangedUTCTime=DateAndTime,
                                                   counter=NewCounter},
            NewActiveAlarms = update_record(UpdatedAlarm, State#alarms_state.active_alarms),
            State#alarms_state{active_alarms = NewActiveAlarms}
    end.

clear_active_alarm(AlarmId, Alarms) ->
    ActiveAlarms = Alarms#alarms_state.active_alarms,
    case proplists:lookup(AlarmId, ActiveAlarms) of
        {AlarmId, FoundAlarm} ->
            CurrentTimeStamp = erlang:system_time(),
            DateAndTime = calendar:local_time_to_universal_time_dst(calendar:local_time()),
            UpdatedAlarm = FoundAlarm#alarm{alarmClearedTime=CurrentTimeStamp,
                                            alarmClearedUTCTime=DateAndTime},
            
            NewActiveAlarms = proplists:delete(AlarmId, ActiveAlarms),
            HistoricalAlarms = [{AlarmId, UpdatedAlarm} | Alarms#alarms_state.historical_alarms],
            {cleared, UpdatedAlarm, 
                  Alarms#alarms_state{active_alarms = NewActiveAlarms,
                                     historical_alarms = HistoricalAlarms}};
        none ->
            no_alarm_registerd %%no action is required
    end.
%%
%% a utility to remove an exisiting element in proplists and
%% a new one and return the new list.
%%
update_record(AlarmRecord, AlarmList) when is_record(AlarmRecord, alarm) ->
    NewList = proplists:delete(AlarmRecord#alarm.alarmId, AlarmList),
    [{AlarmRecord#alarm.alarmId, AlarmRecord} | NewList].